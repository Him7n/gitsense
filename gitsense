#!/bin/bash

# 0. Check for cursor-agent
if ! command -v cursor-agent >/dev/null 2>&1; then
    echo "âŒ 'cursor-agent' CLI is not installed. Please install it first."
    exit 1
fi

# 1. Check for git repo
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "âŒ Not a git repository."
    exit 1
fi

# 2. Get Branch Name (need this early for JIRA detection)
BRANCH_NAME=$(git branch --show-current 2>/dev/null)
if [[ -z "$BRANCH_NAME" ]]; then
    BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
fi
# If it's still empty or "HEAD" (detached), and we can't find a ref, default to 'initial'
if [[ -z "$BRANCH_NAME" || "$BRANCH_NAME" == "HEAD" ]]; then
    BRANCH_NAME="initial"
fi

# 3. Extract JIRA ticket ID from branch name (need this early too)
extract_jira_ticket() {
    local branch="$1"
    # Match patterns like CDS-116548, PROJ-123, etc.
    if [[ "$branch" =~ ([A-Z]+-[0-9]+) ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo ""
    fi
}

JIRA_TICKET=$(extract_jira_ticket "$BRANCH_NAME")

# 4. Get staged changes only (what will actually be committed)
# Note: User must manually stage files before running this script
COMMIT_DIFF=$(git diff --cached -U5 2>/dev/null)
COMMIT_STAT=$(git diff --cached --stat 2>/dev/null)
CHANGE_TYPE="staged"

# Check if we have JIRA ticket - if yes, allow JIRA-only mode even without changes
if [[ -z "$COMMIT_DIFF" ]]; then
    if [[ -z "$JIRA_TICKET" ]]; then
        echo "âš ï¸  No tracked changes found to commit."
        exit 0
    else
        # JIRA-only mode: no commit, but allow PR/JIRA field generation
        echo "âš ï¸  No changes to commit, but JIRA features available."
        JIRA_ONLY_MODE=true
    fi
else
    JIRA_ONLY_MODE=false
fi

# 5. Get repo context for better prompts
REPO_NAME=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo "project")

# Get recent commit history (last 5 commits for style learning)
RECENT_COMMITS=$(git log --oneline -5 --no-decorate 2>/dev/null || echo "No commit history")

# Debug: Show if JIRA ticket detected
if [[ -n "$JIRA_TICKET" ]]; then
    echo "ðŸ“‹ JIRA Ticket detected: $JIRA_TICKET"
fi

# Function to get branch origin point (where it diverged from main/master)
get_branch_origin() {
    # Try to find main or master branch
    local base_branch=""
    if git rev-parse --verify main >/dev/null 2>&1; then
        base_branch="main"
    elif git rev-parse --verify master >/dev/null 2>&1; then
        base_branch="master"
    else
        echo "HEAD~1"
        return
    fi

    # Find merge base (where current branch diverged)
    git merge-base "$base_branch" HEAD 2>/dev/null || echo "HEAD~1"
}

# Function to fetch JIRA ticket information
fetch_jira_info() {
    local ticket_id="$1"
    if ! command -v jira >/dev/null 2>&1; then
        echo "ERROR: jira CLI not found"
        return 1
    fi

    jira issue view "$ticket_id" 2>/dev/null
}

# Function to generate PR title using AI
generate_pr_title() {
    local ticket_id="$1"

    echo -e "\nðŸ·ï¸  Generating PR Title for $ticket_id..."

    # Get JIRA ticket info
    local jira_info=$(fetch_jira_info "$ticket_id")
    if [[ $? -ne 0 || -z "$jira_info" ]]; then
        echo "âš ï¸  Could not fetch JIRA ticket info. Continuing without it..."
        jira_info="No JIRA information available"
    fi

    # Get branch origin and diff
    local branch_origin=$(get_branch_origin)
    local branch_diff=$(git diff "$branch_origin..HEAD" --stat 2>/dev/null)

    # Create AI prompt for PR title
    local pr_title_prompt="ROLE: Pull Request Title Generator

TASK: Generate a concise, descriptive PR title in the following format:

[JIRA-TICKET] Brief description of the main change (max 80 characters)

STRICT RULES:
1. Start with [$ticket_id] in brackets
2. Keep it under 80 characters total
3. Use imperative mood (e.g., 'Add', 'Fix', 'Update', not 'Added', 'Fixed', 'Updated')
4. Focus on the primary change only
5. No markdown formatting
6. No period at the end

TICKET: $ticket_id

JIRA Context:
$jira_info

Changes Made:
$branch_diff
"

    # Generate using cursor-agent
    local pr_title=$(echo "$pr_title_prompt" | cursor-agent --model sonnet-4.5 --print -f 2>/dev/null)

    # Clean up output - extract just the title line
    pr_title=$(echo "$pr_title" | grep "^\[$ticket_id\]" | head -1)

    # Fallback if AI didn't return expected format
    if [[ -z "$pr_title" ]]; then
        pr_title="[$ticket_id] Update code changes"
    fi

    echo "$pr_title"
}

# Function to generate PR description using AI
generate_pr_description() {
    local ticket_id="$1"

    echo -e "\nðŸ“‹ Generating PR Description for $ticket_id..."

    # Get JIRA ticket info
    local jira_info=$(fetch_jira_info "$ticket_id")
    if [[ $? -ne 0 || -z "$jira_info" ]]; then
        echo "âš ï¸  Could not fetch JIRA ticket info. Continuing without it..."
        jira_info="No JIRA information available"
    fi

    # Check for parent Epic
    local parent_epic=""
    local parent_key=""

    # Extract parent key from raw JSON
    local raw_json=$(jira issue view "$ticket_id" --raw 2>/dev/null)
    if [[ -n "$raw_json" ]]; then
        parent_key=$(echo "$raw_json" | grep -o '"parent":\s*{[^}]*"key":"[^"]*"' | grep -o '"key":"[^"]*"' | cut -d'"' -f4 | head -1)
    fi

    if [[ -n "$parent_key" ]]; then
        echo "   Found parent Epic: $parent_key"
        local parent_info=$(jira issue view "$parent_key" 2>/dev/null)
        if [[ $? -eq 0 && -n "$parent_info" ]]; then
            parent_epic="$parent_info"
        fi
    fi

    # Get branch origin
    local branch_origin=$(get_branch_origin)

    # Get all commits since branch diverged
    local all_commits=$(git log --oneline "$branch_origin..HEAD" 2>/dev/null)

    # Get diff from branch origin
    local branch_diff=$(git diff "$branch_origin..HEAD" 2>/dev/null)
    local branch_stat=$(git diff "$branch_origin..HEAD" --stat 2>/dev/null)

    # Find test files in the diff
    local test_files=$(echo "$branch_diff" | grep -E '^\+\+\+ b/.*test.*\.(js|ts|py|java|go|cpp|tsx|jsx)' | sed 's/^+++ b\///' || echo "")

    # Extract test names grouped by file
    local test_names=""

    if [[ -n "$test_files" ]]; then
        while IFS= read -r test_file; do
            # Get the current file being processed from diff
            local current_file_tests=""
            local in_file=false

            # Extract tests from the diff for this specific file
            while IFS= read -r line; do
                # Check if we're in the right file section
                if [[ "$line" =~ ^\+\+\+\ b/$test_file ]]; then
                    in_file=true
                    continue
                fi

                # Check if we've moved to a different file
                if [[ "$line" =~ ^\+\+\+\ b/ ]]; then
                    in_file=false
                fi

                # Extract test names from added lines in this file
                if [[ "$in_file" == "true" && "$line" =~ ^\+.*(it|test|describe)\(.*[\'\"](.*)[\'\"]\) ]]; then
                    local test_name=$(echo "$line" | sed -E "s/^.*\b(it|test|describe)\s*\(\s*['\"]([^'\"]+)['\"].*/\2/")
                    if [[ -n "$test_name" ]]; then
                        current_file_tests="${current_file_tests}  - ${test_name}
"
                    fi
                fi
            done <<< "$branch_diff"

            # If we found tests in this file, add them grouped
            if [[ -n "$current_file_tests" ]]; then
                test_names="${test_names}
${test_file}:
${current_file_tests}"
            fi
        done <<< "$test_files"
    fi

    # Build the prompt dynamically
    local epic_instruction=""
    local epic_context=""
    local test_instruction=""
    local test_context=""

    if [[ -n "$parent_key" ]]; then
        epic_instruction="
If there's a parent Epic mentioned below, add ONE subtle line at end of WHY: 'Part of Epic $parent_key work.'"
        epic_context="
Parent Epic Context:
$parent_epic"
    fi

    if [[ -n "$test_names" ]]; then
        test_instruction="List the test names grouped by file. Format each file group as a separate paragraph with blank line between groups"
        test_context="Test Names Extracted (grouped by file):
$test_names"
    else
        test_instruction="List test files if any, otherwise state 'Manual testing performed'"
        test_context="Test Files Modified:
$test_files"
    fi

    # Create AI prompt for PR description
    local pr_prompt="ROLE: Pull Request Description Generator

TASK: Generate a minimal, concise PR description in the following format:

## WHAT
[One sentence describing what was changed]

## WHY
[One sentence from JIRA ticket explaining the business reason]${epic_instruction}

## HOW
[2-3 bullet points of key technical changes]

## TESTS
[${test_instruction}]

TICKET: $ticket_id

STRICT RULES:
1. Keep it SHORT and minimal
2. Use imperative mood
3. Focus on KEY changes only from the diff
4. Epic context is OPTIONAL - only mention if truly relevant
5. In TESTS section, extract and list individual test names from the provided test files
6. No fluff or unnecessary details

CONTEXT:

JIRA Ticket Info:
$jira_info
${epic_context}

Commits since branch origin:
$all_commits

Files Changed:
$branch_stat

$test_context

Code Diff (first 500 lines):
$(echo "$branch_diff" | head -n 500)
"

    # Generate using cursor-agent
    local pr_output=$(echo "$pr_prompt" | cursor-agent --model sonnet-4.5 --print -f 2>/dev/null)

    # Clean up output
    pr_output=$(echo "$pr_output" | sed 's/```markdown//g' | sed 's/```//g')

    echo "$pr_output"
}

# Function to generate JIRA field suggestions
generate_jira_field_text() {
    local field_type="$1"
    local ticket_id="$2"

    echo -e "\nðŸŽ¯ Generating $field_type for $ticket_id..."

    # Get JIRA ticket info
    local jira_info=$(fetch_jira_info "$ticket_id")

    # Check for parent Epic
    local parent_epic=""
    local parent_key=""
    local raw_json=$(jira issue view "$ticket_id" --raw 2>/dev/null)
    if [[ -n "$raw_json" ]]; then
        parent_key=$(echo "$raw_json" | grep -o '"parent":\s*{[^}]*"key":"[^"]*"' | grep -o '"key":"[^"]*"' | cut -d'"' -f4 | head -1)
    fi

    if [[ -n "$parent_key" ]]; then
        echo "   Found parent Epic: $parent_key"
        local parent_info=$(jira issue view "$parent_key" 2>/dev/null)
        if [[ $? -eq 0 && -n "$parent_info" ]]; then
            parent_epic="$parent_info"
        fi
    fi

    # Get branch origin and diff
    local branch_origin=$(get_branch_origin)
    local branch_diff=$(git diff "$branch_origin..HEAD" --stat 2>/dev/null)

    local field_prompt=""

    case "$field_type" in
        "Bug Resolution")
            field_prompt="Generate a concise Bug Resolution summary (2-3 sentences) explaining:
- Root cause of the bug
- What was fixed
- How it prevents recurrence

Keep it technical but clear."
            ;;
        "CFD Escape Analysis")
            field_prompt="Generate a CFD Escape Analysis (3-4 sentences) explaining:
- Why this escaped to customer
- What process gap allowed it
- What should catch it in future

Be honest and constructive."
            ;;
        "Public Release Notes")
            field_prompt="Generate customer-facing Release Notes (1-2 sentences):
- What capability changed for end users
- Customer benefit
- No internal jargon

Write for non-technical users."
            ;;
        "Feature Justification")
            field_prompt="Generate Feature Justification (2-3 sentences) explaining:
$(if [[ -n "$parent_key" ]]; then echo "- Why this work is needed for Epic $parent_key"; else echo "- Why this feature is needed"; fi)
- What problem it solves
- Expected impact/benefit

Focus on business value."
            ;;
        "Technical Summary")
            field_prompt="Generate Technical Summary (3-4 sentences) for technical audience:
- High-level technical approach
- Key architectural decisions
- Technologies/frameworks used
$(if [[ -n "$parent_key" ]]; then echo "- How it integrates with Epic $parent_key scope"; fi)

Keep it concise but informative."
            ;;
        "QA Notes")
            field_prompt="Generate QA Testing Notes (3-5 bullet points):
- Key test scenarios to verify
- Edge cases to check
- Regression areas to test
- Any special setup needed

Focus on what QA should verify."
            ;;
        "Documentation Update")
            field_prompt="Generate Documentation Update summary (2-3 sentences):
- What documentation needs updating
- Key changes to document
- Where users will be affected

Help tech writers understand what needs documenting."
            ;;
    esac

    local full_prompt="ROLE: JIRA Field Generator

TASK: $field_prompt

TICKET: $ticket_id
$(if [[ -n "$parent_key" ]]; then echo "PARENT EPIC: $parent_key"; fi)

JIRA Context:
$jira_info

$(if [[ -n "$parent_epic" ]]; then echo "Parent Epic Context:
$parent_epic
"; fi)

Changes Made:
$branch_diff
"

    local output=$(echo "$full_prompt" | cursor-agent --model sonnet-4.5 --print -f 2>/dev/null)
    echo "$output"
}

# Function to show a simple loading spinner
show_spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    while [ "$(ps -p $pid -o state= 2>/dev/null)" ]; do
        local temp=${spinstr#?}
        printf " [%c]  " "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
        printf "\b\b\b\b\b\b"
    done
    printf "    \b\b\b\b"
}

# Function to generate messages
generate_messages() {
    local feedback="$1"
    
    ai_msg="ðŸ‘€ Analyzing changes with AI (sonnet-4.5)..."
    echo -n "$ai_msg" >&2
    # Append to analysis output for redrawing
    if [[ -z "$analysis_output" ]]; then
        analysis_output="$ai_msg"
    else
        analysis_output="$analysis_output\n$ai_msg"
    fi

    local system_prompt="ROLE: Git Commit Message Generator.
    
    TASK: Analyze the provided git diff and file statistics. Identify the SINGLE most appropriate Conventional Commit type and intent. Then, generate 5 variations of that SAME message with different phrasing.
    
    CONTEXT:
    - Branch: ${BRANCH_NAME}
    - Project: ${REPO_NAME}
    - Recent commits (for style reference):
${RECENT_COMMITS}

    FILES CHANGED ($CHANGE_TYPE):
${COMMIT_STAT}

    CRITICAL OUTPUT RULES:
    1. Output EXACTLY 5 lines ONLY. NO extra text, NO explanations, NO markdown.
    2. Each line must start with a type: feat, fix, chore, docs, refactor, style, perf, test, ci, or build
    3. Format MUST BE: <type>: [${BRANCH_NAME}]: <description>
    4. All 5 messages MUST use the SAME type (e.g., all 'fix' or all 'feat')
    5. Vary ONLY the description/phrasing (e.g., 'fix: handle null', 'fix: prevent crash', etc.)
    6. DO NOT include: numbering, bullets, markdown, explanations, or any extra text
    
    EXAMPLE OUTPUT (this is what you MUST produce):
    feat: [BRANCH-123]: add user authentication
    feat: [BRANCH-123]: implement login functionality
    feat: [BRANCH-123]: add user credential validation
    feat: [BRANCH-123]: create authentication service
    feat: [BRANCH-123]: enable secure user login

    CONTENT GUIDELINES:
    - Focus on the ACTUAL code changes in the diff below
    - Use imperative mood ('add' not 'added')
    - Be specific about what changed
    - DO NOT hallucinate features not in the diff

    "

    if [[ -n "$feedback" ]]; then
        system_prompt="$system_prompt\n\nUSER FEEDBACK: $feedback\n(Refine the messages based on this feedback)"
    fi

    # Create temp file for the prompt
    local prompt_file=$(mktemp)
    echo "$system_prompt" > "$prompt_file"
    echo -e "\n\n<diff>" >> "$prompt_file"
    echo "$COMMIT_DIFF" | head -n 800 >> "$prompt_file"
    if [[ $(echo "$COMMIT_DIFF" | wc -l) -gt 800 ]]; then
        echo -e "\n... (Diff truncated at 800 lines) ..." >> "$prompt_file"
    fi
    echo -e "</diff>\n" >> "$prompt_file"
    
    local full_prompt=$(cat "$prompt_file")
    local err_file=$(mktemp)
    
    # Run in background to allow for spinner
    cursor-agent --model sonnet-4.5 --print -f "$full_prompt" > "$err_file" 2>&1 &
    local agent_pid=$!
    
    # Kill agent if user Ctrl+C's
    trap "kill $agent_pid 2>/dev/null; rm -f '$prompt_file' '$err_file'; exit" SIGINT SIGTERM
    
    show_spinner "$agent_pid"
    wait "$agent_pid"
    
    # Remove trap
    trap - SIGINT SIGTERM
    
    local raw_output=$(cat "$err_file")
    rm "$prompt_file" "$err_file"
    
    # Check for provider errors
    if echo "$raw_output" | grep -qi "Provider Error\|having trouble connecting"; then
        echo "âš ï¸  AI Provider Error - Grok is temporarily unavailable. Please try again in a moment." >&2
        echo ""
        return 1
    fi
    
    # Debug: Save raw output to temp file for inspection
    # echo "=== RAW AI OUTPUT ===" > /tmp/gitsense_debug.log
    # echo "$raw_output" >> /tmp/gitsense_debug.log
    # echo "====================" >> /tmp/gitsense_debug.log
    
    echo "$raw_output"
}

# State variables
current_feedback=""
refresh_needed=true
declare -a current_options
analysis_output=""

# 4. Interaction Loop
selected_index=0
first_render=true

while true; do
    # JIRA-only mode: skip commit message generation
    if [[ "$JIRA_ONLY_MODE" == "true" ]]; then
        # Show JIRA-only menu
        tput rc
        tput ed

        echo "================================================"
        echo "ðŸŽ¯ JIRA Tools Menu - $JIRA_TICKET"
        echo "================================================"
        echo " No changes to commit, but JIRA tools available:"
        echo ""
        echo " [p] Generate PR Title & Description"
        echo " [f] Generate JIRA Field Text"
        echo " [q] Quit"
        echo "================================================"

        read -rsn1 key

        if [[ "$key" == "p" || "$key" == "P" ]]; then
            tput cnorm
            echo ""
            echo "ðŸ”„ Generating PR Title & Description for $JIRA_TICKET..."
            echo "   (Fetching JIRA ticket, analyzing commits, running AI...)"
            echo ""
            pr_title=$(generate_pr_title "$JIRA_TICKET")
            pr_desc=$(generate_pr_description "$JIRA_TICKET")

            echo ""
            echo "================================================"
            echo "ðŸ·ï¸  PR Title for $JIRA_TICKET"
            echo "================================================"
            echo "$pr_title"
            echo ""
            echo "================================================"
            echo "ðŸ“‹ PR Description for $JIRA_TICKET"
            echo "================================================"
            echo "$pr_desc"
            echo "================================================"

            # Show parent epic info if available
            check_parent=$(jira issue view "$JIRA_TICKET" --raw 2>/dev/null | grep -o '"parent":\s*{[^}]*"key":"[^"]*"' | grep -o '"key":"[^"]*"' | cut -d'"' -f4 | head -1)
            if [[ -n "$check_parent" ]]; then
                echo ""
                echo "â„¹ï¸  Part of Epic: $check_parent"
            fi
            echo ""

            if command -v pbcopy >/dev/null 2>&1; then
                read -p "Copy to clipboard? [Y/n]: " copy_choice < /dev/tty
                if [[ ! "$copy_choice" =~ ^[Nn]$ ]]; then
                    echo "$pr_desc" | pbcopy
                    echo "âœ… Copied to clipboard!"
                fi
            elif command -v xclip >/dev/null 2>&1; then
                read -p "Copy to clipboard? [Y/n]: " copy_choice < /dev/tty
                if [[ ! "$copy_choice" =~ ^[Nn]$ ]]; then
                    echo "$pr_desc" | xclip -selection clipboard
                    echo "âœ… Copied to clipboard!"
                fi
            fi

            echo ""
            read -p "Press any key to return to menu..." -n1 -s < /dev/tty
            tput civis

        elif [[ "$key" == "f" || "$key" == "F" ]]; then
            tput cnorm
            echo ""
            echo "================================================"
            echo "ðŸŽ¯ JIRA Field Generator - $JIRA_TICKET"
            echo "================================================"
            echo " Bug/Quality Fields:"
            echo "   1) Bug Resolution"
            echo "   2) CFD Escape Analysis"
            echo "   3) QA Notes"
            echo ""
            echo " Documentation/Communication:"
            echo "   4) Public Release Notes Summary"
            echo "   5) Feature Justification"
            echo "   6) Documentation Update"
            echo ""
            echo " Technical:"
            echo "   7) Technical Summary"
            echo ""
            echo "   q) Back to main menu"
            echo "================================================"
            read -p "Select field (1-7 or q): " jira_choice < /dev/tty

            case "$jira_choice" in
                1)
                    field_text=$(generate_jira_field_text "Bug Resolution" "$JIRA_TICKET")
                    echo ""
                    echo "--- Bug Resolution ---"
                    echo "$field_text"
                    ;;
                2)
                    echo ""
                    echo "ðŸ”„ Generating CFD Escape Analysis..."
                    field_text=$(generate_jira_field_text "CFD Escape Analysis" "$JIRA_TICKET")
                    echo ""
                    echo "--- CFD Escape Analysis ---"
                    echo "$field_text"
                    ;;
                3)
                    echo ""
                    echo "ðŸ”„ Generating QA Notes..."
                    field_text=$(generate_jira_field_text "QA Notes" "$JIRA_TICKET")
                    echo ""
                    echo "--- QA Notes ---"
                    echo "$field_text"
                    ;;
                4)
                    echo ""
                    echo "ðŸ”„ Generating Public Release Notes..."
                    field_text=$(generate_jira_field_text "Public Release Notes" "$JIRA_TICKET")
                    echo ""
                    echo "--- Public Release Notes ---"
                    echo "$field_text"
                    ;;
                5)
                    echo ""
                    echo "ðŸ”„ Generating Feature Justification..."
                    field_text=$(generate_jira_field_text "Feature Justification" "$JIRA_TICKET")
                    echo ""
                    echo "--- Feature Justification ---"
                    echo "$field_text"
                    ;;
                6)
                    echo ""
                    echo "ðŸ”„ Generating Documentation Update..."
                    field_text=$(generate_jira_field_text "Documentation Update" "$JIRA_TICKET")
                    echo ""
                    echo "--- Documentation Update ---"
                    echo "$field_text"
                    ;;
                7)
                    echo ""
                    echo "ðŸ”„ Generating Technical Summary..."
                    field_text=$(generate_jira_field_text "Technical Summary" "$JIRA_TICKET")
                    echo ""
                    echo "--- Technical Summary ---"
                    echo "$field_text"
                    ;;
                q|Q)
                    tput civis
                    continue
                    ;;
                *)
                    echo "Invalid choice"
                    sleep 1
                    tput civis
                    continue
                    ;;
            esac

            if command -v pbcopy >/dev/null 2>&1; then
                echo ""
                read -p "Copy to clipboard? [Y/n]: " copy_choice < /dev/tty
                if [[ ! "$copy_choice" =~ ^[Nn]$ ]]; then
                    echo "$field_text" | pbcopy
                    echo "âœ… Copied to clipboard!"
                fi
            elif command -v xclip >/dev/null 2>&1; then
                echo ""
                read -p "Copy to clipboard? [Y/n]: " copy_choice < /dev/tty
                if [[ ! "$copy_choice" =~ ^[Nn]$ ]]; then
                    echo "$field_text" | xclip -selection clipboard
                    echo "âœ… Copied to clipboard!"
                fi
            fi

            echo ""
            read -p "Press any key to return to menu..." -n1 -s < /dev/tty
            tput civis

        elif [[ "$key" == "q" || "$key" == "Q" ]]; then
            tput cnorm
            echo -e "\nâŒ Cancelled."
            exit 0
        fi

        continue
    fi

    # Normal mode: Generate commit messages if needed
    if [[ "$refresh_needed" == "true" ]]; then
        raw_output=$(generate_messages "$current_feedback")
        
        # Check if generation failed (empty output or provider error)
        if [[ -z "$raw_output" ]]; then
            echo ""
            echo "âŒ Failed to generate commit messages. Please try again."
            sleep 2
            continue
        fi
        
        # Parse output into array
        current_options=()
        while IFS= read -r line; do
            # 1. Strip ANSI color codes
            clean_line=$(echo "$line" | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g')
            # 2. Clean whitespace
            clean_line=$(echo "$clean_line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            # 3. Remove numbering patterns like "1. ", "1) ", "1- ", "1: "
            clean_line=$(echo "$clean_line" | sed -E 's/^[0-9]+\. *//')
            clean_line=$(echo "$clean_line" | sed -E 's/^[0-9]+\) *//')
            clean_line=$(echo "$clean_line" | sed -E 's/^[0-9]+- *//')
            clean_line=$(echo "$clean_line" | sed -E 's/^[0-9]+: *//')
            # 4. Remove markdown (backticks, asterisks, underscores)
            clean_line=$(echo "$clean_line" | sed -E 's/`//g' | sed -E 's/\*\*//g' | sed -E 's/__//g')
            # 5. Remove "Option X:" prefix if present
            clean_line=$(echo "$clean_line" | sed -E 's/^[Oo]ption +[0-9]+: *//')
            # 6. Skip empty lines
            [[ -z "$clean_line" ]] && continue

            # 7. STRICT FILTER - only lines that start with conventional commit types
            if echo "$clean_line" | grep -Eqi "^(feat|fix|chore|docs|refactor|style|perf|test|ci|build)(\(.*\))?:"; then
                current_options+=("$clean_line")
            fi
        done <<< "$raw_output"
        
        if [[ ${#current_options[@]} -eq 0 ]]; then
            # Debug: Show what we got from AI
            echo "" >&2
            echo "âš ï¸  Warning: AI returned unexpected format. Raw output:" >&2
            echo "---" >&2
            echo "$raw_output" | head -20 >&2
            echo "---" >&2
            echo "" >&2
            current_options+=("Error: AI returned invalid format. Please try refining.")
        fi
        
        refresh_needed=false
        selected_index=0
    fi

    # --- RENDER MENU ---
    # Determine height of the menu to redraw cleanly
    # Header: 3 lines
    # Footer: 3 lines
    # Options: ${#current_options[@]} lines
    # Total lines = 3 + 3 + options
    menu_height=$((3 + 3 + ${#current_options[@]}))

    # On first render, just clear screen or print normally
    # On subsequent renders, move cursor up by menu_height before printing
    if [[ "$first_render" != "true" ]]; then
        tput cuu "$menu_height" # Move cursor UP
        tput ed                 # Clear from cursor to end of screen
    fi

    echo "------------------------------------------------"
    echo "Select a commit message (â†‘/â†“ to move, Enter to select):"
    echo "------------------------------------------------"

    idx=0
    for opt in "${current_options[@]}"; do
        # Color logic
        if [[ "$opt" =~ ^feat ]]; then base_color="\033[32m"; # Green
        elif [[ "$opt" =~ ^fix ]]; then base_color="\033[31m"; # Red
        elif [[ "$opt" =~ ^refactor ]]; then base_color="\033[35m"; # Magenta
        elif [[ "$opt" =~ ^chore ]]; then base_color="\033[33m"; # Yellow
        elif [[ "$opt" =~ ^docs ]]; then base_color="\033[36m"; # Cyan
        else base_color="\033[34m"; fi # Blue

        if [[ $idx -eq $selected_index ]]; then
            # Highlighted Row (Reverse video)
            printf "\033[7m -> ${base_color}${opt}\033[0m\n"
        else
            # Normal Row
            printf "    ${base_color}${opt}\033[0m\n"
        fi
        ((idx++))
    done

    echo "------------------------------------------------"
    pr_menu=""
    if [[ -n "$JIRA_TICKET" ]]; then
        pr_menu="  [p] PR Desc  [f] JIRA Fields"
    fi
    printf " [Enter] Commit  [e] Edit  [c] Copy  [d] Diff  [r] Refine$pr_menu  [?] Help  [q] Quit\n"
    echo "------------------------------------------------"

    # Mark first render as complete
    if [[ "$first_render" == "true" ]]; then
        first_render=false
    fi

    # --- READ INPUT ---
    # Read 1 character silently
    read -rsn1 key

    # Handle Escape Sequences for Arrow Keys
    if [[ "$key" == $'\x1b' ]]; then
        read -rsn2 k2
        if [[ "$k2" == "[A" ]]; then # Up
            ((selected_index--))
            if [[ $selected_index -lt 0 ]]; then selected_index=$((${#current_options[@]} - 1)); fi
        elif [[ "$k2" == "[B" ]]; then # Down
            ((selected_index++))
            if [[ $selected_index -ge ${#current_options[@]} ]]; then selected_index=0; fi
        fi
    
    # Handle Enter (Empty string)
    elif [[ "$key" == "" ]]; then
        MSG_TO_COMMIT="${current_options[$selected_index]}"
        
        echo ""
        echo -e "\033[1;36mâœ“ Selected:\033[0m $MSG_TO_COMMIT"
        read -p "  Skip pre-commit hooks (--no-verify)? [y/N]: " no_verify_flag < /dev/tty
        
        flags=""
        [[ "$no_verify_flag" =~ ^[Yy]$ ]] && flags="--no-verify"
        
        echo "âœ… Committing..."
        git commit -m "$MSG_TO_COMMIT" $flags
        exit 0
        
    # Handle Shortcuts
    elif [[ "$key" == "e" || "$key" == "E" ]]; then
        MSG_TO_COMMIT="${current_options[$selected_index]}"
        if command -v nvim >/dev/null 2>&1; then
            temp_msg_file=$(mktemp)
            echo "$MSG_TO_COMMIT" > "$temp_msg_file"
            # Restore cursor to allow nvim to take full screen properly? 
            # Actually nvim handles terminal state well.
            nvim "$temp_msg_file" < /dev/tty > /dev/tty
            MSG_TO_COMMIT=$(cat "$temp_msg_file")
            rm "$temp_msg_file"
            
            if [[ -n "$MSG_TO_COMMIT" ]]; then
            echo ""
                echo -e "\033[1;36mâœ“ Edited:\033[0m $MSG_TO_COMMIT"
                read -p "  Skip pre-commit hooks (--no-verify)? [y/N]: " no_verify_flag < /dev/tty
                flags=""
                [[ "$no_verify_flag" =~ ^[Yy]$ ]] && flags="--no-verify"
                git commit -m "$MSG_TO_COMMIT" $flags
            exit 0
            fi
        else
            echo "âŒ nvim not found."
            sleep 1
        fi
        
    elif [[ "$key" == "c" || "$key" == "C" ]]; then
         msg="${current_options[$selected_index]}"
         if command -v pbcopy >/dev/null; then
             echo -n "$msg" | pbcopy
             # Print success message briefly then redraw
             echo -e "\nâœ… Copied to clipboard!"
             sleep 1
         elif command -v xclip >/dev/null; then
             echo -n "$msg" | xclip -selection clipboard
             echo -e "\nâœ… Copied to clipboard!"
             sleep 1
         else
             echo -e "\nâŒ Clipboard tool not found."
             sleep 1
         fi
         
    elif [[ "$key" == "d" || "$key" == "D" ]]; then
        # Show diff preview
        echo ""
        echo -e "\033[1;36mðŸ“‹ Diff Preview:\033[0m"
        echo "------------------------------------------------"

        if [[ -n "$COMMIT_DIFF" ]]; then
            # Use less for pagination if available, otherwise cat
            if command -v less >/dev/null 2>&1; then
                echo "$COMMIT_DIFF" | less -R
            else
                echo "$COMMIT_DIFF"
            fi
        else
            echo "No changes to preview."
        fi

        echo ""
        read -p "Press any key to return to menu..." -n1 -s < /dev/tty

    elif [[ "$key" == "r" || "$key" == "R" ]]; then
        echo ""
        # Restore normal cursor for input
        tput cnorm
        read -p "Enter feedback: " user_input < /dev/tty
        current_feedback="$user_input"
        refresh_needed=true
        tput civis # Hide cursor again
        
    elif [[ "$key" == "q" || "$key" == "Q" ]]; then
        tput cnorm # Restore cursor before exit
        echo -e "\nâŒ Cancelled."
        exit 0

    # Better keyboard shortcuts
    elif [[ "$key" == "j" || "$key" == "J" ]]; then
        # Vim-style down navigation
        ((selected_index++))
        if [[ $selected_index -ge ${#current_options[@]} ]]; then selected_index=0; fi

    elif [[ "$key" == "k" || "$key" == "K" ]]; then
        # Vim-style up navigation
        ((selected_index--))
        if [[ $selected_index -lt 0 ]]; then selected_index=$((${#current_options[@]} - 1)); fi

    elif [[ "$key" =~ ^[1-5]$ ]]; then
        # Direct selection by number (1-5)
        direct_index=$((key - 1))
        if [[ $direct_index -lt ${#current_options[@]} ]]; then
            selected_index=$direct_index
            # Auto-commit with selected message
            MSG_TO_COMMIT="${current_options[$selected_index]}"
            echo ""
            echo -e "\033[1;36mâœ“ Selected:\033[0m $MSG_TO_COMMIT"
            read -p "  Skip pre-commit hooks (--no-verify)? [y/N]: " no_verify_flag < /dev/tty

            flags=""
            [[ "$no_verify_flag" =~ ^[Yy]$ ]] && flags="--no-verify"

            echo "âœ… Committing..."
            git commit -m "$MSG_TO_COMMIT" $flags
            # Restore normal screen buffer
            printf '\e[?1049l'
            exit 0
        fi

    elif [[ "$key" == "p" || "$key" == "P" ]]; then
        # Generate PR Description
        if [[ -z "$JIRA_TICKET" ]]; then
            echo -e "\nâš ï¸  No JIRA ticket found in branch name: $BRANCH_NAME"
            sleep 2
        else
            tput cnorm
            echo ""
            echo "ðŸ”„ Generating PR Title & Description for $JIRA_TICKET..."
            echo "   (Fetching JIRA ticket, analyzing commits, running AI...)"
            echo ""
            pr_title=$(generate_pr_title "$JIRA_TICKET")
            pr_desc=$(generate_pr_description "$JIRA_TICKET")

            echo ""
            echo "================================================"
            echo "ðŸ·ï¸  PR Title for $JIRA_TICKET"
            echo "================================================"
            echo "$pr_title"
            echo ""
            echo "================================================"
            echo "ðŸ“‹ PR Description for $JIRA_TICKET"
            echo "================================================"
            echo "$pr_desc"
            echo "================================================"

            # Show parent epic info if available
            check_parent=$(jira issue view "$JIRA_TICKET" --raw 2>/dev/null | grep -o '"parent":\s*{[^}]*"key":"[^"]*"' | grep -o '"key":"[^"]*"' | cut -d'"' -f4 | head -1)
            if [[ -n "$check_parent" ]]; then
                echo ""
                echo "â„¹ï¸  Part of Epic: $check_parent"
            fi
            echo ""

            # Offer to copy to clipboard
            if command -v pbcopy >/dev/null 2>&1; then
                read -p "Copy to clipboard? [Y/n]: " copy_choice < /dev/tty
                if [[ ! "$copy_choice" =~ ^[Nn]$ ]]; then
                    echo -e "$pr_title\n\n$pr_desc" | pbcopy
                    echo "âœ… Copied to clipboard!"
                fi
            elif command -v xclip >/dev/null 2>&1; then
                read -p "Copy to clipboard? [Y/n]: " copy_choice < /dev/tty
                if [[ ! "$copy_choice" =~ ^[Nn]$ ]]; then
                    echo -e "$pr_title\n\n$pr_desc" | xclip -selection clipboard
                    echo "âœ… Copied to clipboard!"
                fi
            fi

            echo ""
            read -p "Press any key to return to menu..." -n1 -s < /dev/tty
            tput civis
        fi

    elif [[ "$key" == "f" || "$key" == "F" ]]; then
        # JIRA Fields Generator Menu
        if [[ -z "$JIRA_TICKET" ]]; then
            echo -e "\nâš ï¸  No JIRA ticket found in branch name: $BRANCH_NAME"
            sleep 2
        else
            tput cnorm
            echo ""
            echo "================================================"
            echo "ðŸŽ¯ JIRA Field Generator - $JIRA_TICKET"
            echo "================================================"
            echo " Bug/Quality Fields:"
            echo "   1) Bug Resolution"
            echo "   2) CFD Escape Analysis"
            echo "   3) QA Notes"
            echo ""
            echo " Documentation/Communication:"
            echo "   4) Public Release Notes Summary"
            echo "   5) Feature Justification"
            echo "   6) Documentation Update"
            echo ""
            echo " Technical:"
            echo "   7) Technical Summary"
            echo ""
            echo "   q) Back to main menu"
            echo "================================================"
            read -p "Select field (1-7 or q): " jira_choice < /dev/tty

            case "$jira_choice" in
                1)
                    echo ""
                    echo "ðŸ”„ Generating Bug Resolution text..."
                    field_text=$(generate_jira_field_text "Bug Resolution" "$JIRA_TICKET")
                    echo ""
                    echo "--- Bug Resolution ---"
                    echo "$field_text"
                    ;;
                2)
                    echo ""
                    echo "ðŸ”„ Generating CFD Escape Analysis..."
                    field_text=$(generate_jira_field_text "CFD Escape Analysis" "$JIRA_TICKET")
                    echo ""
                    echo "--- CFD Escape Analysis ---"
                    echo "$field_text"
                    ;;
                3)
                    echo ""
                    echo "ðŸ”„ Generating QA Notes..."
                    field_text=$(generate_jira_field_text "QA Notes" "$JIRA_TICKET")
                    echo ""
                    echo "--- QA Notes ---"
                    echo "$field_text"
                    ;;
                4)
                    echo ""
                    echo "ðŸ”„ Generating Public Release Notes..."
                    field_text=$(generate_jira_field_text "Public Release Notes" "$JIRA_TICKET")
                    echo ""
                    echo "--- Public Release Notes ---"
                    echo "$field_text"
                    ;;
                5)
                    echo ""
                    echo "ðŸ”„ Generating Feature Justification..."
                    field_text=$(generate_jira_field_text "Feature Justification" "$JIRA_TICKET")
                    echo ""
                    echo "--- Feature Justification ---"
                    echo "$field_text"
                    ;;
                6)
                    echo ""
                    echo "ðŸ”„ Generating Documentation Update..."
                    field_text=$(generate_jira_field_text "Documentation Update" "$JIRA_TICKET")
                    echo ""
                    echo "--- Documentation Update ---"
                    echo "$field_text"
                    ;;
                7)
                    echo ""
                    echo "ðŸ”„ Generating Technical Summary..."
                    field_text=$(generate_jira_field_text "Technical Summary" "$JIRA_TICKET")
                    echo ""
                    echo "--- Technical Summary ---"
                    echo "$field_text"
                    ;;
                q|Q)
                    tput civis
                    continue
                    ;;
                *)
                    echo "Invalid choice"
                    sleep 1
                    tput civis
                    continue
                    ;;
            esac

            # Offer to copy
            if command -v pbcopy >/dev/null 2>&1; then
                echo ""
                read -p "Copy to clipboard? [Y/n]: " copy_choice < /dev/tty
                if [[ ! "$copy_choice" =~ ^[Nn]$ ]]; then
                    echo "$field_text" | pbcopy
                    echo "âœ… Copied to clipboard!"
                fi
            elif command -v xclip >/dev/null 2>&1; then
                echo ""
                read -p "Copy to clipboard? [Y/n]: " copy_choice < /dev/tty
                if [[ ! "$copy_choice" =~ ^[Nn]$ ]]; then
                    echo "$field_text" | xclip -selection clipboard
                    echo "âœ… Copied to clipboard!"
                fi
            fi

            echo ""
            read -p "Press any key to return to menu..." -n1 -s < /dev/tty
            tput civis
        fi

    elif [[ "$key" == "?" ]]; then
        # Show help menu
        echo ""
        echo -e "\033[1;36mðŸ“– Keyboard Shortcuts:\033[0m"
        echo "------------------------------------------------"
        echo " Navigation:"
        echo "   â†‘/â†“ or j/k     Move up/down (vim-style)"
        echo "   1-5            Select and commit directly"
        echo ""
        echo " Actions:"
        echo "   Enter          Commit with selected message"
        echo "   e              Edit message in nvim"
        echo "   c              Copy message to clipboard"
        echo "   d              Preview diff changes"
        echo "   r              Refine AI suggestions"
        if [[ -n "$JIRA_TICKET" ]]; then
        echo ""
        echo " JIRA Integration (Ticket: $JIRA_TICKET):"
        echo "   p              Generate PR title & description"
        echo "   f              Generate JIRA field text"
        fi
        echo ""
        echo " Other:"
        echo "   ?              Show this help"
        echo "   q              Quit without committing"
        echo "------------------------------------------------"
        echo ""
        read -p "Press any key to return to menu..." -n1 -s < /dev/tty

    fi
done

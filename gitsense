#!/bin/bash

# 0. Check for cursor-agent
if ! command -v cursor-agent >/dev/null 2>&1; then
    echo "âŒ 'cursor-agent' CLI is not installed. Please install it first."
    exit 1
fi

# 1. Check for git repo
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "âŒ Not a git repository."
    exit 1
fi

# 2. Get comprehensive diff context
# Get staged changes
STAGED_DIFF=$(git diff --cached -U5 2>/dev/null)
STAGED_STAT=$(git diff --cached --stat 2>/dev/null)

# Get unstaged changes
UNSTAGED_DIFF=$(git diff -U5 2>/dev/null)
UNSTAGED_STAT=$(git diff --stat 2>/dev/null)

# Combine all changes
ALL_DIFF=$(git diff HEAD -U5 2>/dev/null)
ALL_STAT=$(git diff HEAD --stat 2>/dev/null)

# Get untracked files
UNTRACKED=$(git ls-files --others --exclude-standard 2>/dev/null)

if [[ -z "$ALL_DIFF" && -z "$UNTRACKED" ]]; then
    echo "âš ï¸  No changes found (staged or unstaged)."
    exit 0
fi

# 3. Get Branch Name
# We try to get the branch name, suppressing all errors.
BRANCH_NAME=$(git branch --show-current 2>/dev/null)
if [[ -z "$BRANCH_NAME" ]]; then
    BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
fi
# If it's still empty or "HEAD" (detached), and we can't find a ref, default to 'initial'
if [[ -z "$BRANCH_NAME" || "$BRANCH_NAME" == "HEAD" ]]; then
    BRANCH_NAME="initial"
fi

# 4. Get repo context for better prompts
REPO_NAME=$(basename "$(git rev-parse --show-toplevel 2>/dev/null)" 2>/dev/null || echo "project")

# Get recent commit history (last 5 commits for style learning)
RECENT_COMMITS=$(git log --oneline -5 --no-decorate 2>/dev/null || echo "No commit history")

# Function to generate messages
generate_messages() {
    local feedback="$1"
    
    echo -e "ğŸ‘€ Analyzing git diff with cursor-agent (grok-code-fast-1)..." >&2

    # Show comprehensive change summary
    echo -e "\nğŸ“Š Change Summary:" >&2
    echo "$ALL_STAT" | head -n 10 >&2
    if [[ -n "$UNTRACKED" ]]; then
        echo -e "ğŸ“ Untracked files:" >&2
        echo "$UNTRACKED" | head -n 5 >&2
    fi
    echo -e "\n--- DIFF PREVIEW (Shows code changes to be analyzed) ---" >&2
    echo "$ALL_DIFF" | head -n 15 >&2
    echo "--- END PREVIEW ---\n" >&2

    local system_prompt="ROLE: Git Commit Message Generator.

    TASK: Analyze the provided git diff and file statistics. Identify the SINGLE most appropriate Conventional Commit type and intent. Then, generate 5 variations of that SAME message with different phrasing.

    CONTEXT:
    - Branch: ${BRANCH_NAME}
    - Project: ${REPO_NAME}
    - Recent commits (for style reference):
${RECENT_COMMITS}

    FILES CHANGED:
${ALL_STAT}

    STRICT OUTPUT RULES:
    1. Output ONLY 5 lines of text. No markdown.
    2. Format: <type>: [${BRANCH_NAME}]: <description>
    3. All 5 options should ideally have the SAME type (e.g., if it's a fix, all 5 should be 'fix').
    4. Vary the phrasing (e.g., 'fix: handle null', 'fix: prevent crash', 'fix: add null check').

    CONTENT GUIDELINES:
    - Focus on the ACTUAL code changes in the diff.
    - Use imperative mood ('add' not 'added').
    - Do NOT hallucinate features not in the diff.
    - Consider the file paths and statistics shown above.

    TEMPLATE:
    <type>: [${BRANCH_NAME}]: <phrasing option 1>
    <type>: [${BRANCH_NAME}]: <phrasing option 2>
    "

    if [[ -n "$feedback" ]]; then
        system_prompt="$system_prompt\n\nUSER FEEDBACK: $feedback\n(Refine the messages based on this feedback)"
    fi

    # Create temp file for the prompt
    local prompt_file=$(mktemp)
    
    # 1. Write Instructions First
    echo "$system_prompt" > "$prompt_file"
    
    # 2. Add Diff with XML-style tags for better model comprehension
    echo -e "\n\n<diff>" >> "$prompt_file"

    # Use the enhanced diff with more context (U5)
    # Truncate to 800 lines for better context
    echo "$ALL_DIFF" | head -n 800 >> "$prompt_file"
    if [[ $(echo "$ALL_DIFF" | wc -l) -gt 800 ]]; then
        echo -e "\n... (Diff truncated at 800 lines) ..." >> "$prompt_file"
    fi

    echo -e "</diff>\n" >> "$prompt_file"
    
    # Read full content
    local full_prompt=$(cat "$prompt_file")
    
    # Run cursor-agent
    local err_file=$(mktemp)
    
    # Use --print for non-interactive output, and specify the model
    cursor-agent --model grok-code-fast-1 --print "$full_prompt" > "$err_file" 2>&1
    
    # Capture output
    local raw_output=$(cat "$err_file")
    
    # Cleanup
    rm "$prompt_file" "$err_file"
    
    # Return output
    echo "$raw_output"
}

# State variables
current_feedback=""
refresh_needed=true
declare -a current_options

# 4. Interaction Loop
while true; do
    # Generate if needed
    if [[ "$refresh_needed" == "true" ]]; then
        raw_output=$(generate_messages "$current_feedback")
        
        # Parse output into array
        current_options=()
        while IFS= read -r line; do
            # 1. Strip ANSI color codes (common source of regex failures)
            # We use a more aggressive sed pattern for ANSI codes
            clean_line=$(echo "$line" | sed 's/\x1b\[[0-9;]*[a-zA-Z]//g')
            
            # 2. Clean whitespace
            clean_line=$(echo "$clean_line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')
            
            # 3. Remove numbering (1., 1), - )
            clean_line=$(echo "$clean_line" | sed -E 's/^[0-9]+[\.\)\-]?[[:space:]]*//')
            
            # 4. Remove markdown
            clean_line=$(echo "$clean_line" | sed -E 's/`//g')

            # 5. STRICT FILTER: Line must start with a valid type
            # We use grep -i for case-insensitive matching instead of pure bash regex for better portability
            if echo "$clean_line" | grep -Eqi "^[[:space:]]*(feat|fix|chore|docs|refactor|style|perf|test|ci|build)(\(.*\))?:"; then
                current_options+=("$clean_line")
            fi
        done <<< "$raw_output"
        
        # Fallback if no valid options found (model failed completely)
        if [[ ${#current_options[@]} -eq 0 ]]; then
             current_options+=("Error: Model returned invalid format. Raw output (first line):")
             current_options+=("$(echo "$raw_output" | head -n 1)")
             
             # DEBUG: Dump hex to stderr to see invisible chars
             echo "âš ï¸  DEBUG: Raw Output Hex Dump:" >&2
             echo "$raw_output" | head -n 1 | od -c >&2
        fi
        
        refresh_needed=false
    fi

    echo "------------------------------------------------"
    echo "Select a commit message for branch '$BRANCH_NAME':"
    echo "------------------------------------------------"

    # Display Options with color coding by type
    i=1
    for opt in "${current_options[@]}"; do
        # Extract commit type and colorize accordingly
        if [[ "$opt" =~ ^feat ]]; then
            color="\033[1;32m"  # Green for features
        elif [[ "$opt" =~ ^fix ]]; then
            color="\033[1;31m"  # Red for fixes
        elif [[ "$opt" =~ ^refactor ]]; then
            color="\033[1;35m"  # Magenta for refactor
        elif [[ "$opt" =~ ^chore ]]; then
            color="\033[1;33m"  # Yellow for chores
        elif [[ "$opt" =~ ^docs ]]; then
            color="\033[1;36m"  # Cyan for docs
        elif [[ "$opt" =~ ^style ]]; then
            color="\033[1;95m"  # Light magenta for style
        elif [[ "$opt" =~ ^perf ]]; then
            color="\033[1;93m"  # Light yellow for perf
        elif [[ "$opt" =~ ^test ]]; then
            color="\033[1;94m"  # Light blue for test
        else
            color="\033[1;34m"  # Default blue
        fi

        echo -e "${color}$i)\033[0m $opt"
        ((i++))
    done

    echo "------------------------------------------------"
    echo -e "\033[1;32me)\033[0m Edit selected message in nvim"
    echo -e "\033[1;33mr)\033[0m Refine / Give Feedback"
    echo -e "\033[1;31mq)\033[0m Quit"
    echo "------------------------------------------------"

    read -p "Choice: " choice < /dev/tty

    if [[ "$choice" =~ ^[0-9]+$ ]]; then
        # User selected a number
        index=$((choice - 1))
        if [[ $index -ge 0 && $index -lt ${#current_options[@]} ]]; then
            SELECTED_MSG="${current_options[$index]}"

            # Show commit flags menu
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "Selected: $SELECTED_MSG"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "Commit options:"
            echo "  [n] Skip pre-commit hooks (--no-verify)"
            echo "  [a] Amend previous commit (--amend)"
            echo "  [b] Both --no-verify and --amend"
            echo "  [Enter] Commit normally"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            read -p "Option: " commit_option < /dev/tty

            # Build commit flags
            commit_flags=""
            case "$commit_option" in
                n|N)
                    commit_flags="--no-verify"
                    ;;
                a|A)
                    commit_flags="--amend"
                    ;;
                b|B)
                    commit_flags="--no-verify --amend"
                    ;;
                *)
                    commit_flags=""
                    ;;
            esac

            echo ""
            echo "âœ… Committing with: $SELECTED_MSG"
            if [[ -n "$commit_flags" ]]; then
                echo "   Flags: $commit_flags"
                git commit -m "$SELECTED_MSG" $commit_flags
            else
                git commit -m "$SELECTED_MSG"
            fi
            exit 0
        else
            echo "âš ï¸  Invalid number."
        fi
    elif [[ "$choice" == "e" || "$choice" == "E" ]]; then
        echo ""
        echo "Select a message number to edit:"
        read -p "Message number: " edit_choice < /dev/tty

        if [[ "$edit_choice" =~ ^[0-9]+$ ]]; then
            edit_index=$((edit_choice - 1))
            if [[ $edit_index -ge 0 && $edit_index -lt ${#current_options[@]} ]]; then
                # Create temp file with the selected message
                temp_msg_file=$(mktemp)
                echo "${current_options[$edit_index]}" > "$temp_msg_file"

                # Open in nvim
                if command -v nvim >/dev/null 2>&1; then
                    nvim "$temp_msg_file" < /dev/tty > /dev/tty
                    EDITED_MSG=$(cat "$temp_msg_file")
                    rm "$temp_msg_file"

                    if [[ -n "$EDITED_MSG" ]]; then
                        # Show commit flags menu
                        echo ""
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        echo "Edited message: $EDITED_MSG"
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        echo "Commit options:"
                        echo "  [n] Skip pre-commit hooks (--no-verify)"
                        echo "  [a] Amend previous commit (--amend)"
                        echo "  [b] Both --no-verify and --amend"
                        echo "  [Enter] Commit normally"
                        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
                        read -p "Option: " commit_option < /dev/tty

                        # Build commit flags
                        commit_flags=""
                        case "$commit_option" in
                            n|N)
                                commit_flags="--no-verify"
                                ;;
                            a|A)
                                commit_flags="--amend"
                                ;;
                            b|B)
                                commit_flags="--no-verify --amend"
                                ;;
                            *)
                                commit_flags=""
                                ;;
                        esac

                        echo ""
                        echo "âœ… Committing with edited message"
                        if [[ -n "$commit_flags" ]]; then
                            echo "   Flags: $commit_flags"
                            git commit -m "$EDITED_MSG" $commit_flags
                        else
                            git commit -m "$EDITED_MSG"
                        fi
                        exit 0
                    else
                        echo "âš ï¸  Empty message, returning to menu."
                    fi
                else
                    echo "âŒ nvim not found. Please install nvim first."
                fi
            else
                echo "âš ï¸  Invalid number."
            fi
        else
            echo "âš ï¸  Invalid input."
        fi
    elif [[ "$choice" == "r" || "$choice" == "R" ]]; then
        echo ""
        read -p "Enter instructions to improve suggestions: " user_input < /dev/tty
        current_feedback="$user_input"
        refresh_needed=true
    elif [[ "$choice" == "q" || "$choice" == "Q" ]]; then
        echo "âŒ Cancelled."
        exit 0
    else
        echo "âš ï¸  Invalid key."
    fi
done
